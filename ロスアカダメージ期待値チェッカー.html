<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ロスアカ 命中回避判定 ダメージ期待値計算ツール - 比較モード</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      width: 100%;
      padding: 20px;
    }
    fieldset {
      margin-bottom: 20px;
      padding: 15px;
    }
    legend {
      font-weight: bold;
    }
    .slider-group {
      margin-bottom: 10px;
    }
    .slider-group label {
      display: inline-block;
      width: 200px;
    }

    input[type="range"] {
      vertical-align: middle;
      width: 100%;
      margin-right: 10px;
    }

    .value {
      font-weight: bold;
    }
    .calc-group {
      margin-bottom: 40px;
      padding: 10px;
      border: 1px solid #ccc;
    }
    #result, .group-result {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }
    hr {
      margin: 40px 0;
    }
    /* 最適化ボタン用 */
    .optimize-buttons {
      margin: 10px 0;
    }
    .optimize-buttons button {
      margin-right: 10px;
      padding: 5px 10px;
    }
    input[type="number"] {
      width: 60px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ロスアカ 命中回避判定 ダメージ期待値計算ツール</h1>
    <div>
      <label>
        <input type="checkbox" id="calcModeRealtime" checked>
        リアルタイム計算モード
      </label>
      &nbsp;&nbsp;
      <label>
        <input type="checkbox" id="enableBSResistance">
        BS抵抗判定を有効にする
      </label>
    </div>
    <!-- 「能動側最適化」ボタンを追加 -->
    <div class="optimize-buttons">
      <button id="optimizeActiveButton">能動側最適化(実数)</button>
      <button id="singleOptimizeActiveButton">能動側最適化(実数)(シングル)</button>
      <!-- HPを操作しないので事実上同じ -->
      <!-- <button id="optimizeActiveHPRatioButton">能動側最適化(HP比)</button>
      <button id="singleOptimizeActiveHPRatioButton">能動側最適化(HP比)(シングル)</button> -->
      <br>
      <br>
      <button id="optimizePassiveButton">受動側最適化(実数)</button>
      <button id="singleOptimizePassiveButton">受動側最適化(実数)(シングル)</button>
      <button id="optimizePassiveHPRatioButton">受動側最適化(HP比)</button>
      <button id="singleOptimizePassiveHPRatioButton">受動側最適化(HP比)(シングル)</button>
    </div>
    
    <!-- グループ1 -->
    <div class="calc-group" id="group1">
      <h2>グループ 1</h2>
      <!-- 能動側パラメータ -->
      <fieldset>
        <legend>能動側パラメータ</legend>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_main_lock">
          <label for="group1_active_main">主攻:
            <span id="group1_active_main_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_main_min" placeholder="下限" value="100">
          ～
          <input type="number" id="group1_active_main_max" placeholder="上限" value="1500">
          <input type="range" id="group1_active_main" min="50" max="1500" step="10" value="500" oninput="updateValue('group1_active_main_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_sub_lock">
          <label for="group1_active_sub">副攻:
            <span id="group1_active_sub_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_sub_min" placeholder="下限" value="50">
          ～
          <input type="number" id="group1_active_sub_max" placeholder="上限" value="600">
          <input type="range" id="group1_active_sub" min="50" max="600" step="10" value="50" oninput="updateValue('group1_active_sub_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_hit_lock">
          <label for="group1_active_hit">命中:
            <span id="group1_active_hit_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_hit_min" placeholder="下限" value="-10">
          ～
          <input type="number" id="group1_active_hit_max" placeholder="上限" value="100">
          <input type="range" id="group1_active_hit" min="-10" max="100" step="1" value="40" oninput="updateValue('group1_active_hit_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_ct_lock" checked>
          <label for="group1_active_ct">CT:
            <span id="group1_active_ct_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_ct_min" placeholder="下限" value="-1">
          ～
          <input type="number" id="group1_active_ct_max" placeholder="上限" value="100">
          <input type="range" id="group1_active_ct" min="-1" max="100" step="1" value="9" oninput="updateValue('group1_active_ct_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_fb_lock" checked>
          <label for="group1_active_fb">FB:
            <span id="group1_active_fb_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_fb_min" placeholder="下限" value="0">
          ～
          <input type="number" id="group1_active_fb_max" placeholder="上限" value="100">
          <input type="range" id="group1_active_fb" min="0" max="100" step="1" value="15" oninput="updateValue('group1_active_fb_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_active_kenjitsu_lock" checked>
          <label for="group1_active_kenjitsu">堅実:
            <span id="group1_active_kenjitsu_val" class="value"></span>
          </label>
          <input type="number" id="group1_active_kenjitsu_min" placeholder="下限" value="0">
          ～
          <input type="number" id="group1_active_kenjitsu_max" placeholder="上限" value="100">
          <input type="range" id="group1_active_kenjitsu" min="0" max="100" step="1" value="0" oninput="updateValue('group1_active_kenjitsu_val', this.value, 'group1')">
        </div>
      </fieldset>
      
      <!-- 受動側パラメータ -->
      <fieldset>
        <legend>受動側パラメータ</legend>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_hp_lock">
          <label for="group1_passive_hp">HP:
            <span id="group1_passive_hp_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_hp_min" placeholder="下限" value="3000">
          ～
          <input type="number" id="group1_passive_hp_max" placeholder="上限" value="15000">
          <input type="range" id="group1_passive_hp" min="3000" max="15000" step="100" value="6000" oninput="updateValue('group1_passive_hp_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_avoid_lock">
          <label for="group1_passive_avoid">回避:
            <span id="group1_passive_avoid_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_avoid_min" placeholder="下限" value="-20">
          ～
          <input type="number" id="group1_passive_avoid_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_avoid" min="-20" max="100" step="1" value="10" oninput="updateValue('group1_passive_avoid_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_defense_lock">
          <label for="group1_passive_defense">防技:
            <span id="group1_passive_defense_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_defense_min" placeholder="下限" value="-41">
          ～
          <input type="number" id="group1_passive_defense_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_defense" min="-41" max="100" step="1" value="50" oninput="updateValue('group1_passive_defense_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_resistance_lock" checked>
          <label for="group1_passive_resistance">抵抗:
            <span id="group1_passive_resistance_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_resistance_min" placeholder="下限" value="-25">
          ～
          <input type="number" id="group1_passive_resistance_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_resistance" min="-25" max="100" step="1" value="20" oninput="updateValue('group1_passive_resistance_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_ct_lock" checked>
          <label for="group1_passive_ct">CT:
            <span id="group1_passive_ct_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_ct_min" placeholder="下限" value="-1">
          ～
          <input type="number" id="group1_passive_ct_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_ct" min="-1" max="100" step="1" value="9" oninput="updateValue('group1_passive_ct_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_fb_lock" checked>
          <label for="group1_passive_fb">FB:
            <span id="group1_passive_fb_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_fb_min" placeholder="下限" value="0">
          ～
          <input type="number" id="group1_passive_fb_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_fb" min="0" max="100" step="1" value="15" oninput="updateValue('group1_passive_fb_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_koumyou_lock" checked>
          <label for="group1_passive_koumyou">巧妙:
            <span id="group1_passive_koumyou_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_koumyou_min" placeholder="下限" value="0">
          ～
          <input type="number" id="group1_passive_koumyou_max" placeholder="上限" value="100">
          <input type="range" id="group1_passive_koumyou" min="0" max="100" step="1" value="0" oninput="updateValue('group1_passive_koumyou_val', this.value, 'group1')">
        </div>
        <div class="slider-group">
          <input type="checkbox" id="group1_passive_hparmor_lock" checked>
          <label for="group1_passive_hparmor">HP鎧:
            <span id="group1_passive_hparmor_val" class="value"></span>
          </label>
          <input type="number" id="group1_passive_hparmor_min" placeholder="下限" value="0">
          ～
          <input type="number" id="group1_passive_hparmor_max" placeholder="上限" value="200">
          <input type="range" id="group1_passive_hparmor" min="0" max="200" step="1" value="0" oninput="updateValue('group1_passive_hparmor_val', this.value, 'group1')">
        </div>
      </fieldset>
      <div id="group1_result" class="group-result">ダメージ期待値: --</div>
    </div>
    
    <hr>
    
    <!-- グループ2 -->
    <div class="calc-group" id="group2">
      <h2>グループ 2</h2>
      <!-- 能動側パラメータ -->
      <fieldset>
        <legend>能動側パラメータ</legend>
        <div class="slider-group">
          <label for="group2_active_main">主攻:
            <span id="group2_active_main_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_main" min="50" max="1500" step="10" value="500" oninput="updateValue('group2_active_main_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_active_sub">副攻:
            <span id="group2_active_sub_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_sub" min="50" max="600" step="10" value="50" oninput="updateValue('group2_active_sub_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_active_hit">命中:
            <span id="group2_active_hit_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_hit" min="-10" max="100" step="1" value="40" oninput="updateValue('group2_active_hit_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_active_ct">CT:
            <span id="group2_active_ct_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_ct" min="-1" max="100" step="1" value="9" oninput="updateValue('group2_active_ct_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_active_fb">FB:
            <span id="group2_active_fb_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_fb" min="0" max="100" step="1" value="15" oninput="updateValue('group2_active_fb_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_active_kenjitsu">堅実:
            <span id="group2_active_kenjitsu_val" class="value"></span>
          </label>
          <input type="range" id="group2_active_kenjitsu" min="0" max="100" step="1" value="0" oninput="updateValue('group2_active_kenjitsu_val', this.value, 'group2')">
        </div>
      </fieldset>
      
      <!-- 受動側パラメータ -->
      <fieldset>
        <legend>受動側パラメータ</legend>
        <div class="slider-group">
          <label for="group2_passive_hp">HP:
            <span id="group2_passive_hp_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_hp" min="3000" max="15000" step="100" value="6000" oninput="updateValue('group2_passive_hp_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_avoid">回避:
            <span id="group2_passive_avoid_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_avoid" min="-20" max="100" step="1" value="10" oninput="updateValue('group2_passive_avoid_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_defense">防技:
            <span id="group2_passive_defense_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_defense" min="-41" max="100" step="1" value="50" oninput="updateValue('group2_passive_defense_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_resistance">抵抗:
            <span id="group2_passive_resistance_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_resistance" min="-25" max="100" step="1" value="20" oninput="updateValue('group2_passive_resistance_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_ct">CT:
            <span id="group2_passive_ct_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_ct" min="-1" max="100" step="1" value="9" oninput="updateValue('group2_passive_ct_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_fb">FB:
            <span id="group2_passive_fb_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_fb" min="0" max="100" step="1" value="15" oninput="updateValue('group2_passive_fb_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_koumyou">巧妙:
            <span id="group2_passive_koumyou_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_koumyou" min="0" max="100" step="1" value="0" oninput="updateValue('group2_passive_koumyou_val', this.value, 'group2')">
        </div>
        <div class="slider-group">
          <label for="group2_passive_hparmor">HP鎧:
            <span id="group2_passive_hparmor_val" class="value"></span>
          </label>
          <input type="range" id="group2_passive_hparmor" min="0" max="200" step="1" value="0" oninput="updateValue('group2_passive_hparmor_val', this.value, 'group2')">
        </div>
      </fieldset>
      <div id="group2_result" class="group-result">ダメージ期待値: --</div>
    </div>
  </div>

  <script>
    // 20パターンの変化量（[Δhp, Δavoid, Δdefense, Δct, Δfb]）を定義
    const passivePatternList = [
      [400,-4,0,0,0],
      [400,0,-8,0,0],
      [400,0,0,-1,0],
      [400,0,0,0,1],
      [-400,4,0,0,0],
      [0,4,-8,0,0],
      [0,4,0,-1,0],
      [0,4,0,0,1],
      [-400,0,4,0,0],
      [0,-4,8,0,0],
      [0,0,8,-1,0],
      [0,0,8,0,1],
      [-400,0,0,1,0],
      [0,-4,0,1,0],
      [0,0,-8,1,0],
      [0,0,0,1,1],
      [-400,0,0,0,-1],
      [0,-4,0,0,-1],
      [0,0,-8,0,-1],
      [0,0,0,-1,-1],
    ];

    // 6パターンの変化量（[Δhp, Δavoid, Δdefense]）を定義
    const passivePatternListWithoutCF = [
      [100,-1,0],
      [100,0,-2],
      [-100,1,0],
      [0,1,-2],
      [-100,0,2],
      [0,-1,2],
    ]

    
    // 20パターンの変化量（[Δmain, Δsub, Δhit, Δct, Δfb]）を定義
    const activePatternList = [
      [40,-40,0,0,0],
      [40,0,-4,0,0],
      [40,0,0,-1,0],
      [40,0,0,0,1],
      [-40,40,0,0,0],
      [0,40,-4,0,0],
      [0,40,0,-1,0],
      [0,40,0,0,1],
      [-40,0,4,0,0],
      [0,-40,4,0,0],
      [0,0,4,-1,0],
      [0,0,4,0,1],
      [-40,0,0,1,0],
      [0,-40,0,1,0],
      [0,0,-4,1,0],
      [0,0,0,1,1],
      [-40,0,0,0,-1],
      [0,-40,0,0,-1],
      [0,0,-4,0,-1],
      [0,0,0,-1,-1],
    ];

    // 6パターンの変化量（[Δmain, Δsub, Δhit]）を定義
    const activePatternListWithoutCF = [
      [10,-10,0],
      [10,0,-1],
      [-10,10,0],
      [0,10,-1],
      [-10,0,1],
      [0,-10,1],
    ]

    // updateValue：スライダー表示更新 & リアルタイムモード時の再計算
    function updateValue(id, value, groupId) {
      document.getElementById(id).innerText = value;
      if (document.getElementById("calcModeRealtime").checked) {
        calculateGroup(groupId);
      }
    }

    function getDamageFromCache(damageCache, key, computeFn) {
      if (damageCache.has(key)) return damageCache.get(key);
      return null;
    }

    function resistanceCheck(category, defenderFumble, passive_ct, passive_fb, passive_resistance) {
      let countBSChecks = 0;
      let countBSSuccess = 0;

      // BS抵抗値 = 防御側「抵抗」パラメータ + ヒット種別ごとの補正
      let bsBonus = 0;
      if (category === "graze") {
        bsBonus = 50;
      } else if (category === "light") {
        bsBonus = 25;
      } else if (category === "clean") {
        bsBonus = 10;
      } else if (category === "hard") {
        bsBonus = 0;
      } else if (category === "smash") {
        bsBonus = -25;
      }
      let bsResValue = passive_resistance + bsBonus;
      if (defenderFumble || bsResValue < 0) {
        // 抵抗判定の回数を抵抗判定ダイスの1d100の100通り分カウントすることで全て失敗したと意味づける
        countBSChecks += 100;
      } else {
        let successCount = 0;

        for (let bsRoll = 1; bsRoll <= 100; bsRoll++) {
          countBSChecks++;
          const bsCrit = bsRoll >= (100 - passive_ct);
          const bsFumble = bsRoll <= passive_fb;
          let bsSuccess = false;

          if (bsCrit) {
            bsSuccess = true;
          } else if (bsFumble) {
            bsSuccess = false;
          } else {
            if (bsResValue >= 0) {
              const target = 100 - bsResValue;
              bsSuccess = bsRoll >= target;
            } else {
              bsSuccess = false;
            }
          }

          if (bsSuccess) {
            countBSSuccess++;
          }
        }
      }
      return {
        countBSChecks,
        countBSSuccess
      }
    }

    // グループごとの計算関数（BS抵抗判定・各ヒット種別の発生率も算出）
    function calculateGroup(groupId) {
      // 入力値の取得（各要素は groupId + "_" プレフィックス付き）
      const active_main = parseFloat(document.getElementById(groupId + "_active_main").value);
      const active_sub  = parseFloat(document.getElementById(groupId + "_active_sub").value);
      const active_hit  = parseFloat(document.getElementById(groupId + "_active_hit").value);
      const active_ct   = parseFloat(document.getElementById(groupId + "_active_ct").value);
      const active_fb   = parseFloat(document.getElementById(groupId + "_active_fb").value);
      const active_kenjitsu = parseFloat(document.getElementById(groupId + "_active_kenjitsu").value);

      const passive_hp      = parseFloat(document.getElementById(groupId + "_passive_hp").value);
      const passive_avoid   = parseFloat(document.getElementById(groupId + "_passive_avoid").value);
      const passive_defense = parseFloat(document.getElementById(groupId + "_passive_defense").value);
      const passive_ct      = parseFloat(document.getElementById(groupId + "_passive_ct").value);
      const passive_fb      = parseFloat(document.getElementById(groupId + "_passive_fb").value);
      const passive_resistance = parseFloat(document.getElementById(groupId + "_passive_resistance").value);
      const passive_koumyou = parseFloat(document.getElementById(groupId + "_passive_koumyou").value);
      const passive_hparmor = parseFloat(document.getElementById(groupId + "_passive_hparmor").value);

      // カウンター初期化
      let countMiss = 0, countGraze = 0, countLight = 0, countClean = 0, countHard = 0, countSmash = 0, countCriticalLight = 0, countCriticalClean = 0, countCriticalHard = 0, countCriticalSmash = 0;
      let countBSChecks = 0, countBSSuccess = 0;
      let totalDamage = 0;

      const damageCache = new Map();

      // 四重ループ：d_a, d_d, d3, d4
      // 命中ダイス
      for (let d_a = 1; d_a <= 100; d_a++) {
        // 命中判定のダイスがFB値以下なら自動失敗
        // この時は回避判定、命中度判定の1d100×1d100の10000通りのループ（d2ループ×d3ループ）をすべて完全回避した扱いでカウント
        if (d_a <= active_fb) {
          countMiss += 10000; // 内側ループ d2×d3
          continue;
        }
        const attackerRoll = active_hit + d_a;
        const attackerFumble = (d_a <= active_fb);
        const attackerCritical = (d_a >= (100 - active_ct));

        // 回避ダイス
        for (let d_d = 1; d_d <= 100; d_d++) {
          const defenderRoll = passive_avoid + d_d;
          const defenderFumble = (d_d <= passive_fb);
          const defenderCritical = (d_d >= (100 - passive_ct));
          let tmpResistanseCheckResult = null;
          let hit = false, isCritical = false;
          if (attackerFumble) {
            hit = false;
          } else if (defenderCritical) {
            hit = false;
          } else if (attackerCritical) {
            hit = true;
            isCritical = true;
          } else if (defenderFumble) {
            hit = true;
          } else {
            hit = (attackerRoll > defenderRoll);
          }

          // ヒットしなければ命中度判定の1d100の100通りのループ（d3ループ）をすべて完全回避した扱いでカウント
          if (!hit) {
            countMiss += 100; // 内側ループ d3
            continue;
          }

          // 命中度差、堅実値、クリティカルヒット、防技の値をキーにd3ループ以内の判定結果をキャッシュから取得する
          const cacheKey = `${attackerRoll - defenderRoll}_${active_kenjitsu}_${isCritical}_${passive_defense}`;
          const cacheResult = getDamageFromCache(damageCache, cacheKey);
          if (cacheResult !== null) {
            // cacheResultに格納されたavgDamageForOuterPair, d3CountBSChecks, d3CountBSSuccessを使用する
            totalDamage += cacheResult.avgDamageForOuterPair;
            countBSChecks += cacheResult.d3CountBSChecks;
            countBSSuccess += cacheResult.d3CountBSSuccess;

            countMiss += cacheResult.d3CountMiss;
            countGraze += cacheResult.d3CountGraze;
            countLight += cacheResult.d3CountLight;
            countClean += cacheResult.d3CountClean;
            countHard += cacheResult.d3CountHard;
            countSmash += cacheResult.d3CountSmash;
            countCriticalLight += cacheResult.d3CountCriticalLight;
            countCriticalClean += cacheResult.d3CountCriticalClean;
            countCriticalHard += cacheResult.d3CountCriticalHard;
            countCriticalSmash += cacheResult.d3CountCriticalSmash;

            // 次のループに進む
            continue;
          }
          // ヒットの場合：内側ループ（d3：命中度判定、d4：防御技術判定）
          let sumDamageForD3 = 0;
          let d3CountBSChecks = 0, d3CountBSSuccess = 0;
          let d3CountMiss = 0, d3CountGraze = 0, d3CountLight = 0, d3CountClean = 0, d3CountHard = 0, d3CountSmash = 0;
          let d3CountCriticalLight = 0, d3CountCriticalClean = 0, d3CountCriticalHard = 0, d3CountCriticalSmash = 0;
          // 命中度ダイス
          for (let d3 = 1; d3 <= 100; d3++) {
            // 命中度ダイスの補正：堅実の適用（最大値100）
            let correctedDie = d3 + active_kenjitsu;
            if (correctedDie > 100) { correctedDie = 100; }
            
            const hitDegreeDie = d3; // 元のダイス値は命中度補正前の判定用に残す
            const hitDegreeBonus = attackerRoll - defenderRoll;
            let finalHitDegree = hitDegreeBonus + hitDegreeDie;
            
            // 命中度決定1：命中度が100以上なら巧妙の補正を適用（最低50に補正）
            if (finalHitDegree >= 100) {
              finalHitDegree = finalHitDegree - passive_koumyou;
              if (finalHitDegree < 50) {
                finalHitDegree = 50;
              }
            }
            // クリティカル時の最低値補正
            if (isCritical && finalHitDegree < 50) {
              finalHitDegree = 50;
            }

            let mainDamage = 0, subDamage = 0, trueDamage = 0, category = "";
            if (finalHitDegree <= 0) {
              category = "miss";
              d3CountMiss++;
            } else if (finalHitDegree <= 49) {
              category = "graze";
              d3CountGraze++;
              mainDamage = Math.floor(active_main * ((15 + (correctedDie / 4)) / 100));
            } else if (finalHitDegree <= 99) {
              category = "light";
              d3CountLight++;
              if (isCritical) {
                d3CountCriticalLight++;
              }
              mainDamage = Math.floor(active_main * ((30 + (correctedDie / 2)) / 100));
            } else if (finalHitDegree <= 149) {
              category = "clean";
              d3CountClean++;
              if (isCritical) {
                d3CountCriticalClean++;
              }
              mainDamage = active_main;
              subDamage = isCritical ? 0 : active_sub;
              trueDamage = isCritical ? (active_sub * 2) : 0;
            } else if (finalHitDegree <= 199) {
              category = "hard";
              d3CountHard++;
              if (isCritical) {
                d3CountCriticalHard++;
              }
              let multiplier = (100 + Math.floor(correctedDie / 2)) / 100;
              mainDamage = Math.floor(active_main * multiplier);
              trueDamage = Math.floor((isCritical ? active_sub * 2 : active_sub) * multiplier);

            } else {
              category = "smash";
              d3CountSmash++;
              if (isCritical) {
                d3CountCriticalSmash++;
              }
              let multiplier = (100 + correctedDie) / 100;
              mainDamage = Math.floor(active_main * multiplier);
              trueDamage = Math.floor((isCritical ? active_sub * 2 : active_sub) * multiplier);
            }

            let sumDamageAfterDefense = 0;
            // 防御技術判定（d4）ループ（回避ファンブルしていない場合 かつ 防技がマイナスでない場合）
            if (!defenderFumble && passive_defense >= 0) {
              for (let d4 = 1; d4 <= 100; d4++) {
                const defenseDie = d4;
                const defenseTarget = 100 - passive_defense;
                const defenseFumble = (defenseDie <= passive_fb);
                const defenseCrit = (defenseDie >= (100 - passive_ct));
                const defenseSuccess = !defenseFumble && (defenseCrit || (defenseDie >= defenseTarget));
                let damageAfterDefense = mainDamage + subDamage;
                if (defenseFumble) {
                  damageAfterDefense = (mainDamage * 1.3) + subDamage;
                } else if (defenseSuccess) {
                  damageAfterDefense = (mainDamage + subDamage) * 0.3;
                }
                // 防技判定結果反映
                damageAfterDefense = (damageAfterDefense + trueDamage);
                // HP鎧の適用：クリーンヒット以上の場合のみ、最終HPダメージから軽減（0未満にならないように）
                if (category === "clean" || category === "hard" || category === "smash") {
                  damageAfterDefense = Math.max(0, damageAfterDefense - passive_hparmor);
                }
                sumDamageAfterDefense += damageAfterDefense;
              }
              // 防技判定まで経由した平均ダメージ
              let avgDamageAfterDefense = sumDamageAfterDefense / 100;
              sumDamageForD3 += avgDamageAfterDefense;
            } else {

              let defenseCheckedMainDamage = mainDamage;
              let extraMultiplier = 0;
              const neg = -passive_defense;
              if (neg >= 1 && neg <= 10) { extraMultiplier = 0.20; }
              else if (neg >= 11 && neg <= 20) { extraMultiplier = 0.40; }
              else if (neg >= 21 && neg <= 30) { extraMultiplier = 0.60; }
              else if (neg >= 31 && neg <= 40) { extraMultiplier = 0.80; }
              else if (neg >= 41) { extraMultiplier = 1.00; }
              
              // TODO:2025/04/10時点で未実装の要素 回避判定FBや防技マイナスの場合も主攻ダメ1.3倍の防技判定FBチェックだけ行う
              // for (let d4 = 1; d4 <= 100; d4++) {
              //   const defenseDie = d4;
              //   const defenseTarget = 100 - passive_defense;
              //   const defenseFumble = (defenseDie <= passive_fb);
              //   if (defenseFumble) {
              //     defenseCheckedMainDamage = (mainDamage * 1.3);
              //   }
              //   // 防技マイナス時の追加ダメージ反映
              //   let damageAfterDefenseCheck = (defenseCheckedMainDamage + subDamage + trueDamage) * (1 + extraMultiplier);
              //   // HP鎧の適用：クリーンヒット以上の場合のみ、最終HPダメージから軽減（0未満にならないように）
              //   if (category === "clean" || category === "hard" || category === "smash") {
              //     damageAfterDefenseCheck = Math.max(0, damageAfterDefenseCheck - passive_hparmor);
              //   }
              //   sumDamageAfterDefense += damageAfterDefenseCheck;
              // }
              // // 防技判定まで経由した平均ダメージ
              // let avgDamageAfterDefense = sumDamageAfterDefense / 100;
              // sumDamageForD3 += avgDamageAfterDefense;

              // 2025/04/10時点の仕様
              sumDamageForD3 += (defenseCheckedMainDamage + subDamage + trueDamage) * (1 + extraMultiplier);

            }

            // BS抵抗判定シミュレーション（チェックオンかつ防御側回避判定でファンブルでない場合）
            if (document.getElementById("enableBSResistance").checked) {
              tmpResistanseCheckResult = resistanceCheck(category, defenderFumble, passive_ct, passive_fb, passive_resistance);
              d3CountBSChecks += tmpResistanseCheckResult.countBSChecks;
              d3CountBSSuccess += tmpResistanseCheckResult.countBSSuccess;
            }
          }

          // d3ループ分の平均を算出
          const avgDamageForOuterPair = sumDamageForD3 / 100;
          totalDamage += avgDamageForOuterPair;
          countBSChecks += d3CountBSChecks;
          countBSSuccess += d3CountBSSuccess;
          countMiss += d3CountMiss;
          countGraze += d3CountGraze;
          countLight += d3CountLight;
          countClean += d3CountClean;
          countHard += d3CountHard;
          countSmash += d3CountSmash;
          countCriticalLight += d3CountCriticalLight;
          countCriticalClean += d3CountCriticalClean;
          countCriticalHard += d3CountCriticalHard;
          countCriticalSmash += d3CountCriticalSmash;
          
          damageCache.set(cacheKey, {
            avgDamageForOuterPair,
            d3CountBSChecks,
            d3CountBSSuccess,
            d3CountMiss,
            d3CountGraze,
            d3CountLight,
            d3CountClean,
            d3CountHard,
            d3CountSmash,
            d3CountCriticalLight,
            d3CountCriticalClean,
            d3CountCriticalHard,
            d3CountCriticalSmash
          });
        }
      }

      // 総試行数は、外側の (d_a, d_d) × d3 = 100^2×100 = 100^3
      const totalOutcomes = Math.pow(100, 3);
      let pMiss    = (countMiss / totalOutcomes) * 100;
      let pGraze   = (countGraze / totalOutcomes) * 100;
      let pLight   = (countLight / totalOutcomes) * 100;
      let pClean   = (countClean / totalOutcomes) * 100;
      let pHard    = (countHard / totalOutcomes) * 100;
      let pSmash   = (countSmash / totalOutcomes) * 100;
      let pCleanOrHigher = pClean + pHard + pSmash;
      let pCriticalCleanOrHigher = ((countCriticalClean + countCriticalHard + countCriticalSmash) / totalOutcomes) * 100;
      let pBSResist = (countBSChecks > 0 ? (countBSSuccess / countBSChecks) * 100 : 0);
      // 外側ループ（d_a,d_d）の各組み合わせごとに d3 の平均を取っているので、全体の平均は d_a×d_d=100×100で割る
      const expectedDamage = totalDamage / (100 * 100);

      document.getElementById(groupId + "_result").innerHTML =
        "ダメージ期待値: " + expectedDamage.toFixed(2) + "<br>" +
        "完全回避率: " + pMiss.toFixed(2) + "%<br>" +
        "グレイズヒット率: " + pGraze.toFixed(2) + "%<br>" +
        "ライトヒット率: " + pLight.toFixed(2) + "%<br>" +
        "クリーンヒット率: " + pClean.toFixed(2) + "%<br>" +
        "ハードヒット率: " + pHard.toFixed(2) + "%<br>" +
        "スマッシュヒット率: " + pSmash.toFixed(2) + "%<br>" +
        "クリーンヒット以上発生率: " + pCleanOrHigher.toFixed(2) + "%</br>" +
        "クリティカルかつクリーンヒット以上発生率: " + pCriticalCleanOrHigher.toFixed(2) + "%</br>" +
        "BS抵抗率: " + pBSResist.toFixed(2) + "%";

      document.getElementById(`${groupId}_active_main_val`).textContent = document.getElementById(`${groupId}_active_main`).value;
      document.getElementById(`${groupId}_active_sub_val`).textContent = document.getElementById(`${groupId}_active_sub`).value;
      document.getElementById(`${groupId}_active_hit_val`).textContent = document.getElementById(`${groupId}_active_hit`).value;
      document.getElementById(`${groupId}_active_ct_val`).textContent = document.getElementById(`${groupId}_active_ct`).value;
      document.getElementById(`${groupId}_active_fb_val`).textContent = document.getElementById(`${groupId}_active_fb`).value;
      document.getElementById(`${groupId}_active_kenjitsu_val`).textContent = document.getElementById(`${groupId}_active_kenjitsu`).value;
      document.getElementById(`${groupId}_passive_hp_val`).textContent = document.getElementById(`${groupId}_passive_hp`).value;
      document.getElementById(`${groupId}_passive_avoid_val`).textContent = document.getElementById(`${groupId}_passive_avoid`).value;
      document.getElementById(`${groupId}_passive_defense_val`).textContent = document.getElementById(`${groupId}_passive_defense`).value;
      document.getElementById(`${groupId}_passive_resistance_val`).textContent = document.getElementById(`${groupId}_passive_resistance`).value;
      document.getElementById(`${groupId}_passive_ct_val`).textContent = document.getElementById(`${groupId}_passive_ct`).value;
      document.getElementById(`${groupId}_passive_fb_val`).textContent = document.getElementById(`${groupId}_passive_fb`).value;
      document.getElementById(`${groupId}_passive_koumyou_val`).textContent = document.getElementById(`${groupId}_passive_koumyou`).value;
      document.getElementById(`${groupId}_passive_hparmor_val`).textContent = document.getElementById(`${groupId}_passive_hparmor`).value;

      exportCalculationResults(groupId);
    }

    // computeExpectedDamage：シミュレーション部分を関数化
    function computeExpectedDamage(active, passiveFull) {
      let countMiss = 0, countGraze = 0, countLight = 0, countClean = 0, countHard = 0, countSmash = 0, countCriticalLight = 0, countCriticalClean = 0, countCriticalHard = 0, countCriticalSmash = 0;
      let countBSChecks = 0, countBSSuccess = 0;
      let totalDamage = 0;
      
      const damageCache = new Map();

      // 命中ダイス
      for (let d_a = 1; d_a <= 100; d_a++) {
        // 命中判定のダイスがFB値以下なら自動失敗
        // この時は回避判定、命中度判定の1d100×1d100の10000通りのループ（d2ループ×d3ループ）をすべて完全回避した扱いでカウント
        if (d_a <= active.fb) {
          countMiss += 10000; // 内側ループ d2×d3
          continue;
        }
        const attackerRoll = active.hit + d_a;
        const attackerFumble = (d_a <= active.fb);
        const attackerCritical = (d_a >= (100 - active.ct));
        // 回避ダイス
        for (let d_d = 1; d_d <= 100; d_d++) {
          const defenderRoll = passiveFull.avoid + d_d;
          const defenderFumble = (d_d <= passiveFull.fb);
          const defenderCritical = (d_d >= (100 - passiveFull.ct));
          let hit = false, isCritical = false;
          if (attackerFumble) { hit = false; }
          else if (defenderCritical) { hit = false; }
          else if (attackerCritical) { hit = true; isCritical = true; }
          else if (defenderFumble) { hit = true; }
          else { hit = (attackerRoll > defenderRoll); }
          if (!hit) { countMiss += 100; continue; }

          // 命中度差、堅実値、クリティカルヒット、防技の値をキーにd3ループ以内の判定結果をキャッシュから取得する
          const cacheKey = `${attackerRoll - defenderRoll}_${active.kenjitsu}_${isCritical}_${passiveFull.defense}`;
          const cacheResult = getDamageFromCache(damageCache, cacheKey);
          if (cacheResult !== null) {
            // cacheResultに格納されたavgDamageForOuterPairを使用する
            totalDamage += cacheResult.avgDamageForOuterPair;
            // 次のループに進む
            continue;
          }

          let sumDamageForD3 = 0;
          // 命中度ダイス
          for (let d3 = 1; d3 <= 100; d3++) {
            let correctedDie = d3 + active.kenjitsu;
            if (correctedDie > 100) { correctedDie = 100; }
            const hitDegreeDie = d3;
            const hitDegreeBonus = attackerRoll - defenderRoll;
            let finalHitDegree = hitDegreeBonus + hitDegreeDie;
            if (finalHitDegree >= 100) {
              finalHitDegree = finalHitDegree - passiveFull.koumyou;
              if (finalHitDegree < 50) { finalHitDegree = 50; }
            }
            if (isCritical && finalHitDegree < 50) { finalHitDegree = 50; }
            let mainDamage = 0, subDamage = 0, trueDamage = 0, category = "";
            if (finalHitDegree <= 0) { category = "miss"; countMiss++; }
            else if (finalHitDegree <= 49) {
              category = "graze"; countGraze++;
              mainDamage = Math.floor(active.main * ((15 + (correctedDie / 4)) / 100));
            } else if (finalHitDegree <= 99) {
              category = "light"; countLight++;
              if (isCritical) countCriticalLight++;
              mainDamage = Math.floor(active.main * ((30 + (correctedDie / 2)) / 100));
            } else if (finalHitDegree <= 149) {
              category = "clean"; countClean++;
              if (isCritical) countCriticalClean++;
              mainDamage = active.main;
              subDamage = isCritical ? 0 : active.sub;
              trueDamage = isCritical ? (active.sub * 2) : 0;
            } else if (finalHitDegree <= 199) {
              category = "hard"; countHard++;
              if (isCritical) countCriticalHard++;
              let multiplier = (100 + Math.floor(correctedDie / 2)) / 100;
              mainDamage = Math.floor(active.main * multiplier);
              trueDamage = Math.floor((isCritical ? active.sub * 2 : active.sub) * multiplier);
            } else {
              category = "smash"; countSmash++;
              if (isCritical) countCriticalSmash++;
              let multiplier = (100 + correctedDie) / 100;
              mainDamage = Math.floor(active.main * multiplier);
              trueDamage = Math.floor((isCritical ? active.sub * 2 : active.sub) * multiplier);
            }
            let sumDamageAfterDefense = 0;
            // 回避ファンブルしていない場合 かつ 防技がマイナスでない場合
            if (!defenderFumble && passiveFull.defense >= 0) {
              // 防技ダイス
              for (let d4 = 1; d4 <= 100; d4++) {
                const defenseDie = d4;
                const defenseTarget = 100 - passiveFull.defense;
                const defenseFumble = (defenseDie <= passiveFull.fb);
                const defenseCrit = (defenseDie >= (100 - passiveFull.ct));
                const defenseSuccess = !defenseFumble && (defenseCrit || (defenseDie >= defenseTarget));
                let damageAfterDefense = mainDamage + subDamage;
                if (defenseFumble) {
                  damageAfterDefense = (mainDamage * 1.3) + subDamage;
                } else if (defenseSuccess) {
                  damageAfterDefense = (mainDamage + subDamage) * 0.3;
                }
                // 防技判定結果反映
                damageAfterDefense = (damageAfterDefense + trueDamage);
                // HP鎧の処理
                if (category === "clean" || category === "hard" || category === "smash") {
                  damageAfterDefense = Math.max(0, damageAfterDefense - passiveFull.hparmor);
                }
                sumDamageAfterDefense += damageAfterDefense;
              }
              // 防技判定まで経由した平均ダメージ
              let avgDamageAfterDefense = sumDamageAfterDefense / 100;
              sumDamageForD3 += avgDamageAfterDefense;
            } else {

              let defenseCheckedMainDamage = mainDamage;
              let extraMultiplier = 0;
              const neg = -passiveFull.defense;
              if (neg >= 1 && neg <= 10) { extraMultiplier = 0.20; }
              else if (neg >= 11 && neg <= 20) { extraMultiplier = 0.40; }
              else if (neg >= 21 && neg <= 30) { extraMultiplier = 0.60; }
              else if (neg >= 31 && neg <= 40) { extraMultiplier = 0.80; }
              else if (neg >= 41) { extraMultiplier = 1.00; }

              // TODO:2025/04/10時点で未実装の要素 回避判定FBや防技マイナスの場合も主攻ダメ1.3倍の防技判定FBチェックだけ行う
              // for (let d4 = 1; d4 <= 100; d4++) {
              //   const defenseDie = d4;
              //   const defenseTarget = 100 - passiveFull.defense;
              //   const defenseFumble = (defenseDie <= passiveFull.fb);
              //   if (defenseFumble) {
              //     defenseCheckedMainDamage = (mainDamage * 1.3);
              //   }
              //   // 防技判定結果反映
              //   let damageAfterDefenseCheck = (defenseCheckedMainDamage + subDamage + trueDamage) * (1 + extraMultiplier);
              //   // HP鎧の処理
              //   if (category === "clean" || category === "hard" || category === "smash") {
              //     damageAfterDefenseCheck = Math.max(0, damageAfterDefenseCheck - passiveFull.hparmor);
              //   }
              //   sumDamageAfterDefense += damageAfterDefenseCheck;
              // }
              // // 防技判定まで経由した平均ダメージ
              // let avgDamageAfterDefense = sumDamageAfterDefense / 100;
              // sumDamageForD3 += avgDamageAfterDefense;
              
              // 2025/04/10時点の仕様
              sumDamageForD3 += (defenseCheckedMainDamage + subDamage + trueDamage) * (1 + extraMultiplier);
            }
          }
          // 命中度判定まで経由した平均ダメージ
          const avgDamageForOuterPair = sumDamageForD3 / 100;
          totalDamage += avgDamageForOuterPair;
          damageCache.set(cacheKey, {avgDamageForOuterPair});
        }
      }
      // 命中回避判定の全パターンの平均ダメージ
      return totalDamage / (100 * 100);
    }
    
    // 現在のグループ1受動側ステータスを取得
    function getCurrentPassiveStatus() {
      return {
        hp: parseFloat(document.getElementById("group1_passive_hp").value),
        avoid: parseFloat(document.getElementById("group1_passive_avoid").value),
        defense: parseFloat(document.getElementById("group1_passive_defense").value),
        ct: parseFloat(document.getElementById("group1_passive_ct").value),
        fb: parseFloat(document.getElementById("group1_passive_fb").value),
        resistance: parseFloat(document.getElementById("group1_passive_resistance").value),
        koumyou: parseFloat(document.getElementById("group1_passive_koumyou").value),
        hparmor: parseFloat(document.getElementById("group1_passive_hparmor").value)
      };
    }

    // 現在のグループ1能動側ステータスを取得
    function getCurrentActiveStatus() {
      return {
        main: parseFloat(document.getElementById("group1_active_main").value),
        sub:  parseFloat(document.getElementById("group1_active_sub").value),
        hit:  parseFloat(document.getElementById("group1_active_hit").value),
        ct:   parseFloat(document.getElementById("group1_active_ct").value),
        fb:   parseFloat(document.getElementById("group1_active_fb").value),
        kenjitsu: parseFloat(document.getElementById("group1_active_kenjitsu").value)
      };
    }

    // 能動側最適化：複数回ループして最適な評価値配分を求め、ベストをグループ2に反映
    function optimizeActiveIterative(hpRatio) {
      let bestCandidate = iterativeOptimizeActive(100, 10, hpRatio);

      if (bestCandidate) {
        setActiveStatus(bestCandidate, "group2");
        
        // 最適化後の候補をグループ2に反映する補助関数
        document.getElementById("group2_passive_hp").value = document.getElementById("group1_passive_hp").value;
        document.getElementById("group2_passive_avoid").value = document.getElementById("group1_passive_avoid").value;
        document.getElementById("group2_passive_defense").value = document.getElementById("group1_passive_defense").value;
        document.getElementById("group2_passive_ct").value = document.getElementById("group1_passive_ct").value;
        document.getElementById("group2_passive_fb").value = document.getElementById("group1_passive_fb").value;
        document.getElementById("group2_passive_resistance").value = document.getElementById("group1_passive_resistance").value;
        document.getElementById("group2_passive_koumyou").value = document.getElementById("group1_passive_koumyou").value;
        document.getElementById("group2_passive_hparmor").value = document.getElementById("group1_passive_hparmor").value;

        // 表示用のspanを手動で更新（updateValueは使わない）
        document.getElementById("group2_passive_hp_val").textContent = document.getElementById("group1_passive_hp").value;
        document.getElementById("group2_passive_avoid_val").textContent = document.getElementById("group1_passive_avoid").value;
        document.getElementById("group2_passive_defense_val").textContent = document.getElementById("group1_passive_defense").value;
        document.getElementById("group2_passive_ct_val").textContent = document.getElementById("group1_passive_ct").value;
        document.getElementById("group2_passive_fb_val").textContent = document.getElementById("group1_passive_fb").value;
        document.getElementById("group2_passive_resistance_val").textContent = document.getElementById("group1_passive_resistance").value;
        document.getElementById("group2_passive_koumyou_val").textContent = document.getElementById("group1_passive_koumyou").value;
        document.getElementById("group2_passive_hparmor_val").textContent = document.getElementById("group1_passive_hparmor").value;
        
        calculateGroup("group2");
      }
    }

    // 能動側最適化：複数回ループして最適な評価値配分を求め、ベストをグループ1に反映
    function singleOptimizeActiveIterative(hpRatio = false) {
      const bestCandidate = iterativeOptimizeActive(1, 10, hpRatio);
      
      if (bestCandidate) {
        setActiveStatus(bestCandidate, "group1");
        calculateGroup("group1");
      }
    }

    // 能動側最適化：外側ループで繰り返し評価し、改善が見られなくなったら終了する
    function iterativeOptimizeActive(maxIterations = 100, noImprovementLimit = 10, hpRatio = false) {
      // 初期状態をグループ1から取得
      let currentCandidate = getCurrentActiveStatus();
      let bestDamage = computeExpectedDamage(currentCandidate, getCurrentPassiveStatus());
      if (hpRatio) {
        bestDamage = bestDamage / parseInt(document.getElementById('group1_passive_hp').value);
      }
      
      // console.log(`${bestDamage}→`);
      // 探索履歴を管理する Set（JSON.stringify で文字列キー化）
      const evaluatedCandidates = new Set();
      evaluatedCandidates.add(JSON.stringify(currentCandidate));

      let iteration = 0;
      let noImprovementCount = 0;

      // 入力値の制限チェック
      const minHit = parseInt(document.getElementById('group1_active_hit_min').value);
      const maxHit = parseInt(document.getElementById('group1_active_hit_max').value);
      const minMain = parseInt(document.getElementById('group1_active_main_min').value);
      const maxMain = parseInt(document.getElementById('group1_active_main_max').value);
      const minSub = parseInt(document.getElementById('group1_active_sub_min').value);
      const maxSub = parseInt(document.getElementById('group1_active_sub_max').value);
      const minCt = parseFloat(document.getElementById('group1_active_ct_min').value);
      const maxCt = parseFloat(document.getElementById('group1_active_ct_max').value);
      const minFb = parseFloat(document.getElementById('group1_active_fb_min').value);
      const maxFb = parseFloat(document.getElementById('group1_active_fb_max').value);

      while (iteration < maxIterations && noImprovementCount < noImprovementLimit) {
        let localBestCandidate = null;
        let localBestDamage = bestDamage;
        
        if (document.getElementById("group1_active_ct_lock").checked && document.getElementById("group1_active_fb_lock").checked) {
          // 20パターンの候補を評価
          for (let i = 0; i < activePatternListWithoutCF.length; i++) {
            const delta = activePatternListWithoutCF[i];

            // ロックされているパラメータについては、deltaが0でなければこの候補は無効
            if (document.getElementById("group1_active_main_lock").checked && delta[0] !== 0) continue;
            if (document.getElementById("group1_active_sub_lock").checked && delta[1] !== 0) continue;
            if (document.getElementById("group1_active_hit_lock").checked && delta[2] !== 0) continue;
            
            const candidate = {
              main: currentCandidate.main + delta[0],
              sub:  currentCandidate.sub  + delta[1],
              hit:  currentCandidate.hit  + delta[2],
              ct:   currentCandidate.ct,
              fb:   currentCandidate.fb,
              kenjitsu:   currentCandidate.kenjitsu
            };
            const key = JSON.stringify(candidate);
            // すでに評価済みならスキップ
            if (evaluatedCandidates.has(key)) continue;
            evaluatedCandidates.add(key);

            let dmg = 0;

            // 範囲チェック（各スライダーの制約を確認）
            if (
              candidate.hit < minHit || candidate.hit > maxHit ||
              candidate.main < minMain || candidate.main > maxMain ||
              candidate.sub < minSub || candidate.sub > maxSub ||
              candidate.ct < minCt || candidate.ct > maxCt ||
              candidate.fb < minFb || candidate.fb > maxFb
            ) {
              // 範囲外ならスキップ
            } else {
              dmg = computeExpectedDamage(candidate, getCurrentPassiveStatus());
              if (hpRatio) {
                dmg = dmg / parseInt(document.getElementById('group1_passive_hp').value);
              }
              if (dmg > localBestDamage) {
                localBestDamage = dmg;
                localBestCandidate = candidate;
              }
            }
          }
        } else {
          // 20パターンの候補を評価
          for (let i = 0; i < activePatternList.length; i++) {
            const delta = activePatternList[i];

            // ロックされているパラメータについては、deltaが0でなければこの候補は無効
            if (document.getElementById("group1_active_main_lock").checked && delta[0] !== 0) continue;
            if (document.getElementById("group1_active_sub_lock").checked && delta[1] !== 0) continue;
            if (document.getElementById("group1_active_hit_lock").checked && delta[2] !== 0) continue;
            if (document.getElementById("group1_active_ct_lock").checked && delta[3] !== 0) continue;
            if (document.getElementById("group1_active_fb_lock").checked && delta[4] !== 0) continue;
            
            const candidate = {
              main: currentCandidate.main + delta[0],
              sub:  currentCandidate.sub  + delta[1],
              hit:  currentCandidate.hit  + delta[2],
              ct:   currentCandidate.ct   + delta[3],
              fb:   currentCandidate.fb   + delta[4],
              kenjitsu:   currentCandidate.kenjitsu
            };
            const key = JSON.stringify(candidate);
            // すでに評価済みならスキップ
            if (evaluatedCandidates.has(key)) continue;
            evaluatedCandidates.add(key);

            let dmg = 0;

            // 範囲チェック（各スライダーの制約を確認）
            if (
              candidate.hit < minHit || candidate.hit > maxHit ||
              candidate.main < minMain || candidate.main > maxMain ||
              candidate.sub < minSub || candidate.sub > maxSub ||
              candidate.ct < minCt || candidate.ct > maxCt ||
              candidate.fb < minFb || candidate.fb > maxFb
            ) {
              // 範囲外ならスキップ
            } else {
              dmg = computeExpectedDamage(candidate, getCurrentPassiveStatus());
              if (hpRatio) {
                dmg = dmg / parseInt(document.getElementById('group1_passive_hp').value);
              }
              if (dmg > localBestDamage) {
                localBestDamage = dmg;
                localBestCandidate = candidate;
              }
            }
          }
        }

        // 改善があった場合は出発点を更新し、改善なしならカウンターを増加
        if (localBestCandidate && localBestDamage > bestDamage) {
          bestDamage = localBestDamage;
          currentCandidate = localBestCandidate;
          noImprovementCount = 0;
        } else {
          noImprovementCount++;
        }
        iteration++;
      }
      // console.log(`${bestDamage}`);
      return currentCandidate;
    }

    

    // 能動側最適化：複数回ループして最適な評価値配分を求め、ベストをグループ2に反映
    function optimizePassiveIterative(hpRatio) {
      const bestCandidate = iterativeOptimizePassive(100, 10, hpRatio);

      if (bestCandidate) {
        setPassiveStatus(bestCandidate, "group2");

        // 最適化後の候補をグループ2に反映する補助関数
        document.getElementById("group2_active_main").value = document.getElementById("group1_active_main").value;
        document.getElementById("group2_active_sub").value = document.getElementById("group1_active_sub").value;
        document.getElementById("group2_active_hit").value = document.getElementById("group1_active_hit").value;
        document.getElementById("group2_active_ct").value = document.getElementById("group1_active_ct").value;
        document.getElementById("group2_active_fb").value = document.getElementById("group1_active_fb").value;
        document.getElementById("group2_active_kenjitsu").value = document.getElementById("group1_active_kenjitsu").value;

        // 表示用のspanを手動で更新（updateValueは使わない）
        document.getElementById("group2_active_main_val").textContent = document.getElementById("group1_active_main").value;
        document.getElementById("group2_active_sub_val").textContent = document.getElementById("group1_active_sub").value;
        document.getElementById("group2_active_hit_val").textContent = document.getElementById("group1_active_hit").value;
        document.getElementById("group2_active_ct_val").textContent = document.getElementById("group1_active_ct").value;
        document.getElementById("group2_active_fb_val").textContent = document.getElementById("group1_active_fb").value;
        document.getElementById("group2_active_kenjitsu_val").textContent = document.getElementById("group1_active_kenjitsu").value;

        calculateGroup("group2");
      }
    }

    // 能動側最適化：複数回ループして最適な評価値配分を求め、ベストをグループ1に反映
    function singleOptimizePassiveIterative(hpRatio) {
      const bestCandidate = iterativeOptimizePassive(1, 10, hpRatio);
     
      if (bestCandidate) {
        setPassiveStatus(bestCandidate, "group1");
        calculateGroup("group1");
      }
    }

    // 能動側最適化：外側ループで繰り返し評価し、改善が見られなくなったら終了する
    function iterativeOptimizePassive(maxIterations = 100, noImprovementLimit = 10, hpRatio = false) {
      // 初期状態をグループ1から取得
      let currentCandidate = getCurrentPassiveStatus();
      let bestDamage = computeExpectedDamage(getCurrentActiveStatus(), currentCandidate);
      
      if (hpRatio) {
        bestDamage = bestDamage / currentCandidate.hp;
      }
      
      // console.log(`${bestDamage}→`);
      // 探索履歴を管理する Set（JSON.stringify で文字列キー化）
      const evaluatedCandidates = new Set();
      evaluatedCandidates.add(JSON.stringify(currentCandidate));

      let iteration = 0;
      let noImprovementCount = 0;

      
      // 入力値の制限チェック
      const minHp = parseInt(document.getElementById('group1_passive_hp_min').value);
      const maxHp = parseInt(document.getElementById('group1_passive_hp_max').value);
      const minAvoid = parseInt(document.getElementById('group1_passive_avoid_min').value);
      const maxAvoid = parseInt(document.getElementById('group1_passive_avoid_max').value);
      const minDefense = parseInt(document.getElementById('group1_passive_defense_min').value);
      const maxDefense = parseInt(document.getElementById('group1_passive_defense_max').value);
      const minCt = parseFloat(document.getElementById('group1_passive_ct_min').value);
      const maxCt = parseFloat(document.getElementById('group1_passive_ct_max').value);
      const minFb = parseFloat(document.getElementById('group1_passive_fb_min').value);
      const maxFb = parseFloat(document.getElementById('group1_passive_fb_max').value);

      while (iteration < maxIterations && noImprovementCount < noImprovementLimit) {
        let localBestCandidate = null;
        let localBestDamage = bestDamage;
        
        if (document.getElementById("group1_passive_ct_lock").checked && document.getElementById("group1_passive_fb_lock").checked) {
          // 20パターンの候補を評価
          for (let i = 0; i < passivePatternListWithoutCF.length; i++) {
            const delta = passivePatternListWithoutCF[i];

            // ロックされているパラメータについては、deltaが0でなければこの候補は無効
            if (document.getElementById("group1_passive_hp_lock").checked && delta[0] !== 0) continue;
            if (document.getElementById("group1_passive_avoid_lock").checked && delta[1] !== 0) continue;
            if (document.getElementById("group1_passive_defense_lock").checked && delta[2] !== 0) continue;
            
            const candidate = {
              hp: currentCandidate.hp + delta[0],
              avoid:  currentCandidate.avoid  + delta[1],
              defense:  currentCandidate.defense  + delta[2],
              resistance:   currentCandidate.resistance,
              ct:   currentCandidate.ct,
              fb:   currentCandidate.fb,
              koumyou: currentCandidate.koumyou,
              hparmor: currentCandidate.hparmor
            };
            const key = JSON.stringify(candidate);
            // すでに評価済みならスキップ
            if (evaluatedCandidates.has(key)) continue;
            evaluatedCandidates.add(key);

            let dmg = 0;

            // 範囲チェック（各スライダーの制約を確認）
            if (
              candidate.hp < minHp || candidate.hp > maxHp ||
              candidate.avoid < minAvoid || candidate.avoid > maxAvoid ||
              candidate.defense < minDefense || candidate.defense > maxDefense ||
              candidate.ct < minCt || candidate.ct > maxCt ||
              candidate.fb < minFb || candidate.fb > maxFb
            ) {
              // 範囲外ならスキップ
            } else {
              dmg = computeExpectedDamage(getCurrentActiveStatus(), candidate);
              if (hpRatio) {
                dmg = dmg / candidate.hp;
              }
              if (dmg < localBestDamage) {
                localBestDamage = dmg;
                localBestCandidate = candidate;
              }
            }
          }
        } else {
          // 20パターンの候補を評価
          for (let i = 0; i < passivePatternList.length; i++) {
            const delta = passivePatternList[i];

            // ロックされているパラメータについては、deltaが0でなければこの候補は無効
            if (document.getElementById("group1_passive_hp_lock").checked && delta[0] !== 0) continue;
            if (document.getElementById("group1_passive_avoid_lock").checked && delta[1] !== 0) continue;
            if (document.getElementById("group1_passive_defense_lock").checked && delta[2] !== 0) continue;
            if (document.getElementById("group1_passive_ct_lock").checked && delta[3] !== 0) continue;
            if (document.getElementById("group1_passive_fb_lock").checked && delta[4] !== 0) continue;
            
            const candidate = {
              hp: currentCandidate.hp + delta[0],
              avoid:  currentCandidate.avoid  + delta[1],
              defense:  currentCandidate.defense  + delta[2],
              resistance: currentCandidate.resistance,
              ct:   currentCandidate.ct   + delta[3],
              fb:   currentCandidate.fb   + delta[4],
              koumyou:   currentCandidate.koumyou,
              hparmor:   currentCandidate.hparmor
            };
            const key = JSON.stringify(candidate);
            // すでに評価済みならスキップ
            if (evaluatedCandidates.has(key)) continue;
            evaluatedCandidates.add(key);

            let dmg = 0;

            // 範囲チェック（各スライダーの制約を確認）
            if (
              candidate.hp < minHp || candidate.hp > maxHp ||
              candidate.avoid < minAvoid || candidate.avoid > maxAvoid ||
              candidate.defense < minDefense || candidate.defense > maxDefense ||
              candidate.ct < minCt || candidate.ct > maxCt ||
              candidate.fb < minFb || candidate.fb > maxFb
            ) {
              // 範囲外ならスキップ
            } else {
              dmg = computeExpectedDamage(getCurrentActiveStatus(), candidate);
              if (hpRatio) {
                dmg = dmg / candidate.hp;
              }
              if (dmg < localBestDamage) {
                localBestDamage = dmg;
                localBestCandidate = candidate;
              }
            }
          }
        }

        // 改善があった場合は出発点を更新し、改善なしならカウンターを増加
        if (localBestCandidate && localBestDamage < bestDamage) {
          bestDamage = localBestDamage;
          currentCandidate = localBestCandidate;
          noImprovementCount = 0;
        } else {
          noImprovementCount++;
        }
        iteration++;
      }
      // console.log(`${bestDamage}`);
      return currentCandidate;
    }

    // 最適化後の候補をグループ2に反映する補助関数
    function setActiveStatus(candidate, groupId) {
      document.getElementById(groupId + "_active_main").value = candidate.main;
      document.getElementById(groupId + "_active_sub").value = candidate.sub;
      document.getElementById(groupId + "_active_hit").value = candidate.hit;
      document.getElementById(groupId + "_active_ct").value = candidate.ct;
      document.getElementById(groupId + "_active_fb").value = candidate.fb;
      document.getElementById(groupId + "_active_kenjitsu").value = candidate.kenjitsu;

      // 表示用のspanを手動で更新（updateValueは使わない）
      document.getElementById(groupId + "_active_main_val").textContent = candidate.main;
      document.getElementById(groupId + "_active_sub_val").textContent = candidate.sub;
      document.getElementById(groupId + "_active_hit_val").textContent = candidate.hit;
      document.getElementById(groupId + "_active_ct_val").textContent = candidate.ct;
      document.getElementById(groupId + "_active_fb_val").textContent = candidate.fb;
      document.getElementById(groupId + "_active_kenjitsu_val").textContent = candidate.kenjitsu;

      // 計算は最後に1回だけ
      calculateGroup(groupId);
    }

    function setPassiveStatus(candidate, groupId) {
      document.getElementById(groupId + "_passive_hp").value = candidate.hp;
      document.getElementById(groupId + "_passive_avoid").value = candidate.avoid;
      document.getElementById(groupId + "_passive_defense").value = candidate.defense;
      document.getElementById(groupId + "_passive_resistance").value = candidate.resistance;
      document.getElementById(groupId + "_passive_ct").value = candidate.ct;
      document.getElementById(groupId + "_passive_fb").value = candidate.fb;
      document.getElementById(groupId + "_passive_koumyou").value = candidate.koumyou;
      document.getElementById(groupId + "_passive_hparmor").value = candidate.hparmor;

      // 表示用のspanを手動で更新（updateValueは使わない）
      document.getElementById(groupId + "_passive_hp_val").textContent = candidate.hp;
      document.getElementById(groupId + "_passive_avoid_val").textContent = candidate.avoid;
      document.getElementById(groupId + "_passive_defense_val").textContent = candidate.defense;
      document.getElementById(groupId + "_passive_resistance_val").textContent = candidate.resistance;
      document.getElementById(groupId + "_passive_ct_val").textContent = candidate.ct;
      document.getElementById(groupId + "_passive_fb_val").textContent = candidate.fb;
      document.getElementById(groupId + "_passive_koumyou_val").textContent = candidate.koumyou;
      document.getElementById(groupId + "_passive_hparmor_val").textContent = candidate.hparmor;

      // 計算は最後に1回だけ
      calculateGroup(groupId);
    }

    function exportCalculationResults(groupId) {
      // グループのパラメータを取得
      const parameters = {
          active: {
              main: parseFloat(document.getElementById(groupId + "_active_main").value),
              sub: parseFloat(document.getElementById(groupId + "_active_sub").value),
              hit: parseFloat(document.getElementById(groupId + "_active_hit").value),
              ct: parseFloat(document.getElementById(groupId + "_active_ct").value),
              fb: parseFloat(document.getElementById(groupId + "_active_fb").value),
              kenjitsu: parseFloat(document.getElementById(groupId + "_active_kenjitsu").value)
          },
          passive: {
              hp: parseFloat(document.getElementById(groupId + "_passive_hp").value),
              avoid: parseFloat(document.getElementById(groupId + "_passive_avoid").value),
              defense: parseFloat(document.getElementById(groupId + "_passive_defense").value),
              ct: parseFloat(document.getElementById(groupId + "_passive_ct").value),
              fb: parseFloat(document.getElementById(groupId + "_passive_fb").value),
              resistance: parseFloat(document.getElementById(groupId + "_passive_resistance").value),
              koumyou: parseFloat(document.getElementById(groupId + "_passive_koumyou").value),
              hparmor: parseFloat(document.getElementById(groupId + "_passive_hparmor").value)
          }
      };

      // 計算結果を取得
      const resultText = document.getElementById(groupId + "_result").innerText.split("\n");
      const results = {};
      resultText.forEach(line => {
          const parts = line.split(": ");
          if (parts.length === 2) {
              const key = parts[0].trim();
              const value = parts[1].trim();
              results[key] = value;
          }
      });

      // JSON データを作成
      const jsonData = {
          group: groupId,
          parameters: parameters,
          results: results
      };

      // console.log(jsonData.results['ダメージ期待値']);

      // // JSON ファイルを生成してダウンロード
      // const jsonString = JSON.stringify(jsonData, null, 2);
      // const blob = new Blob([jsonString], { type: "application/json" });
      // const a = document.createElement("a");
      // a.href = URL.createObjectURL(blob);
      // a.download = groupId + "_calculation_results.json";
      // a.click();
    }

    // 「JSON 出力」ボタンを作成
    function addExportButton(groupId) {
        const button = document.createElement("button");
        button.innerText = "JSON 出力";
        button.onclick = function () {
            exportCalculationResults(groupId);
        };
        document.getElementById(groupId).appendChild(button);
    }

    // 各グループのスライダー change イベント設定
    document.addEventListener("DOMContentLoaded", function () {
      const groups = ["group1", "group2"];
      groups.forEach(function(groupId) {
        const sliderIds = [
          groupId + "_active_main",
          groupId + "_active_sub",
          groupId + "_active_hit",
          groupId + "_active_ct",
          groupId + "_active_fb",
          groupId + "_active_kenjitsu",
          groupId + "_passive_hp",
          groupId + "_passive_avoid",
          groupId + "_passive_defense",
          groupId + "_passive_ct",
          groupId + "_passive_fb",
          groupId + "_passive_resistance",
          groupId + "_passive_koumyou",
          groupId + "_passive_hparmor"
        ];
        sliderIds.forEach(function(id) {
          document.getElementById(id).addEventListener("change", function() {
            if (!document.getElementById("calcModeRealtime").checked) {
              calculateGroup(groupId);
            }
          });
        });
      });
      document.getElementById("calcModeRealtime").addEventListener("change", function() {
        ["group1", "group2"].forEach(function(groupId) {
          calculateGroup(groupId);
        });
      });
      document.getElementById("enableBSResistance").addEventListener("change", function() {
        ["group1", "group2"].forEach(function(groupId) {
          calculateGroup(groupId);
        });
      });
    });
    
    // 「能動側最適化」ボタン
    document.getElementById("optimizeActiveButton").addEventListener("click", () => {optimizeActiveIterative()});

    // 「能動側最適化(シングル)」ボタン
    document.getElementById("singleOptimizeActiveButton").addEventListener("click", () => {singleOptimizeActiveIterative()});

    // HPを操作しないので事実上同じ処理
    // // HP比の要素を取り入れて計算する場合
    // // 「能動側最適化」ボタン
    // document.getElementById("optimizeActiveHPRatioButton").addEventListener("click", () => {optimizeActiveIterative(true)});

    // // 「能動側最適化(シングル)」ボタン
    // document.getElementById("singleOptimizeActiveHPRatioButton").addEventListener("click", () => {singleOptimizeActiveIterative(true)});

    // HP比の要素を取り入れて計算する場合
    // 「受動側最適化」ボタン
    document.getElementById("optimizePassiveButton").addEventListener("click", () => {optimizePassiveIterative()});

    // 「受動側最適化(シングル)」ボタン
    document.getElementById("singleOptimizePassiveButton").addEventListener("click", () => {singleOptimizePassiveIterative()});

    // 「受動側最適化」ボタン
    document.getElementById("optimizePassiveHPRatioButton").addEventListener("click", () => {optimizePassiveIterative(true)});

    // 「受動側最適化(シングル)」ボタン
    document.getElementById("singleOptimizePassiveHPRatioButton").addEventListener("click", () => {singleOptimizePassiveIterative(true)});


    // スライダーの下限・上限をリアルタイムで他グループに反映する
    const changeSlider = (index, sourceGroup) => {
      const sourceMin = parseInt(document.getElementById(`${sourceGroup}_${index}_min`).value);
      const sourceMax = parseInt(document.getElementById(`${sourceGroup}_${index}_max`).value);

      if (isNaN(sourceMin) || isNaN(sourceMax) || sourceMin > sourceMax) return;

      // group1, group2 両方に反映
      ['group1', 'group2'].forEach(group => {
        // min/maxのinput欄にも反映
        // document.getElementById(`${group}_${index}_min`).value = sourceMin;
        // document.getElementById(`${group}_${index}_max`).value = sourceMax;

        // スライダーにも反映
        const slider = document.getElementById(`${group}_${index}`);
        slider.min = sourceMin;
        slider.max = sourceMax;

        // 現在のスライダー値が範囲外だった場合の補正（必要なら）
        if (parseInt(slider.value) < sourceMin) slider.value = sourceMin;
        if (parseInt(slider.value) > sourceMax) slider.value = sourceMax;
      });
    };

    ['group1'].forEach(group => {
      ['min', 'max'].forEach(suffix => {
        document.getElementById(`${group}_active_main_${suffix}`).addEventListener('input', () => changeSlider(`active_main`, group));
        document.getElementById(`${group}_active_sub_${suffix}`).addEventListener('input', () => changeSlider(`active_sub`, group));
        document.getElementById(`${group}_active_hit_${suffix}`).addEventListener('input', () => changeSlider(`active_hit`, group));
        document.getElementById(`${group}_active_ct_${suffix}`).addEventListener('input', () => changeSlider(`active_ct`, group));
        document.getElementById(`${group}_active_fb_${suffix}`).addEventListener('input', () => changeSlider(`active_fb`, group));
        document.getElementById(`${group}_active_kenjitsu_${suffix}`).addEventListener('input', () => changeSlider(`active_kenjitsu`, group));
        document.getElementById(`${group}_passive_hp_${suffix}`).addEventListener('input', () => changeSlider(`passive_hp`, group));
        document.getElementById(`${group}_passive_avoid_${suffix}`).addEventListener('input', () => changeSlider(`passive_avoid`, group));
        document.getElementById(`${group}_passive_defense_${suffix}`).addEventListener('input', () => changeSlider(`passive_defense`, group));
        document.getElementById(`${group}_passive_resistance_${suffix}`).addEventListener('input', () => changeSlider(`passive_resistance`, group));
        document.getElementById(`${group}_passive_ct_${suffix}`).addEventListener('input', () => changeSlider(`passive_ct`, group));
        document.getElementById(`${group}_passive_fb_${suffix}`).addEventListener('input', () => changeSlider(`passive_fb`, group));
        document.getElementById(`${group}_passive_koumyou_${suffix}`).addEventListener('input', () => changeSlider(`passive_koumyou`, group));
        document.getElementById(`${group}_passive_hparmor_${suffix}`).addEventListener('input', () => changeSlider(`passive_hparmor`, group));
      });
    });
      
    // ブラウザが値を反映し終わってから値を取得
    window.addEventListener("load", function () {
      setTimeout(() => {
        // 初期計算
        calculateGroup("group1");
        calculateGroup("group2");
      }, 0); // 必要に応じて遅延時間を100ms等に調整する
    });
    
    // 計算結果をJSON出力してダウンロードするボタン
    // （コンソールログに出力する方式に変更したためコメントアウト）
    // addExportButton("group1");
    // addExportButton("group2");
    
  </script>
</body>
</html>
